//先检查临界情况

//输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。
只要不是根节点,左右子树递归,返回值+1

//写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。
不考虑进位+进位情况->各个位&然后左移一位;
仍然会有进位问题:转换为非进位+进位部分之和,迭代
疑惑:为何迭代有终点

//镜像二叉树
互换左右子树根节点,
然后递归

//变态跳台阶
f(0);f(1);迭代f(1)....f(N)

//给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1];B[i]=A[0]..a[i-1]
B存放前i项,当前B[i]=B[i-1]*A[i]

//用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
1、push,将数据直接压入stack1即可；
2、pop,将stack1中的数据弹出压入到stack2中，则数据顺序相反，为保证最先进入的数据一直处于栈顶，只有将stack2中的数据全部pop后，才能继续讲stack1中的数据压入到stack2中，继续做pop

//求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C)
ans && (ans += Solution(n - 1));

//输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
劣质解法:位数超过int溢出的情况罕见,不断左移,计算位数
优解:消去个位为1的情况,消去从左至右第一个1

//我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？
更一般的结论，如果用1*m的方块覆盖m*n区域，递推关系式为f(n) = f(n-1) + f(n-m)，(n > m)

//给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方
???

//连续子数组的最大和
当前数组首元素记为最大值:若当前+下一个小于下一个->当前取下一个;若当前+下一个比历史最大大,更新最大值

//输入一棵二叉树，判断该二叉树是否是平衡二叉树。
//??只要高度符合条件??
递归遍历根的高度,根左右子树的高度,求高度也使用递归计算

//两个链表的第一个公共结点
找出2个链表的长度，然后让长的先走两个链表的长度差，然后再一起走

//字符流中第一个不重复的字符
1、用一个128大小的数组统计每个字符出现的次数,cnt[ch-'\0']
2  用一个队列，如果第一次遇到ch字符，则插入队列；其他情况不在插入
3  插入时最后判断是否cnt[data.front()]<2,是则返回字符,否则弹出队列
O（N）是在insert函数中已经解决了，单从数组中取是O（1)

//包含min函数的栈
1 最小栈:每次压入->当前元素和栈顶元素 中的最小值
2 数据栈:每次插入数据都压入数据

//数值的整数次方
1幂为零,取r=1(初值)
2幂为正负,取绝对p:
3迭代:p与个位进行位运算==1,r*=base;
每次迭代时base*=base;p右移一位
4指数为负数,结果取倒数

//旋转数组的最小数字
怎么缩小?见核心代码:rotateArray[left] 与 rotateArray[mid]比较
如果旋转后第一个元素较中间大:第一个元素位于大数组,中间元素位于小数组
如果旋转后第一个元素较中间小:第一个元素位于大数组,第二个元素也位于大数组,但在>第一个元素右边
查找的缺陷:出现中间左边右边都相等的情况,只能遍历搜索

//对称的二叉树
递归版本:
1 同结点结构是否null,"同null" or "一null一not null" 则 return
2 结点内值是否相等,false 则 return
3 一个对左字树递归,一个对右子树递归,若为镜像,始终return true;

//把二叉树打印成多行:从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。
非空情况:放根于队列
迭代队列非空:弹出根结点存入其数值,把非空的左右子树加入队列中

//一个链表中包含环，请找出该链表的环的入口结点。
p1走1步,p2走2步,当p1==p2时,记当前步数x:p1继续,p2从头走:-->p1走了x和p2从头走x会在入口结点处相遇


//左旋转字符串
1 直接先将字符串完整叠加 str+=str
2 再从拼接的字符串的第n位开始,截取取原长

//统计一个数字在排序数组中出现的次数。
二分查找 找到第一个K 和 最后一个K 二者位置相减
找最后索引时候,即使找到,在mid+1仍可找到情况下让start=1+mid
找最先索引时候,即使找到让mid-k仍可找到情况下end=mid-1

//二叉树的下一个结点:结点包含左右和父节点指针
如果有右子树，则找右子树的最左节点
没右子树，则找第一个当前节点是父节点左孩子的节点
退到了根节点仍没找到，则返回null

//和为S的两个数字
相差越远乘积越小
迭代i<j:
直到sum符合条件
while(i < j && a[i] + a[j] > sum) --j;
while(i < j && a[i] + a[j] < sum) ++i;

//二叉搜索树转换成一个排序的双向链表
非递归版本:
递归版本:
先递归执行,第一参数(cur->left)左接第二参数,补充右接,让第一参数指向第二参数;
convertHelper(cur ->left, pre);XXXX;convertHelper(cur ->right, pre);
最后返回最左左子树的



//输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
递归版本:
均非空
谁小谁得到newhead,newhead->next=递归(newhead->next与pheadX)

//输入一个链表，反转链表后，输出链表的所有元素。
栈压入数据,弹栈存入vector

//数组中重复的数字
第一次遍历
用哈希表存放所有元素,数值为其个数
第二次遍历
将哈希表值>1等元素存入另一个数组 duplication[count++],同时返回true

//栈的压入、弹出序列
压入序列压入创建的栈,与出栈序列首元素不相等继续压入,相等则弹出

//斐波那契数列
迭代:
从2开始迭代
递归:
return Fibonacci(n-1)+Fibonacci(n-2)

//数组中只出现一次的数字
一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

//把二叉树打印成多行
根非空元素非空,入队列
迭代队列非空:
去当前队列长度:弹出队头元素入vector,压入左右子树根节点
TODO

//按之字形顺序打印二叉树
取用两个栈奇数层使用栈1偶数层使用栈2
TODO

//从上往下打印二叉树
非空情况:
迭代队列非空:
出队列头
取得队列头的val到vector
队列的左右子树根节点入队


//数组中出现次数超过一半的数字
若存在他的计数会大于等于1
若不存在,遍历一遍第一步得带的num,用count*2>n验证,会返回0

//树的子结构:输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
在HasSubtree中:
先判断pRoot1,2 是否有某指针为空,有则false
同时在递归调用A树的left,right,有逻辑|| 连接,同调用isSubTree(A,B)
在isSubTree中:
只要参数2为空return true,
只要参数1为空return false;
最后返回 参12的p->val值是否相等 &&  递归调用参12左子树 && 递归调用参12右子树

//字符串转换成整数
首元素判断是否含+-,用s=+-1表示符号位
迭代:
根据是否有正负确定迭代的起点0or1
运用字符比较,在'0'~'9'之间
每次迭代对结果res=res*10+str[i]-'0'
迭代完毕
res*s(符号位)

//表示数值的字符串
用bool 标记符号、小数点、e是否出现过
迭代循环字符串长度次:
4个情况分析
1 为e/E,只能出现1次;不能在最后一位,因为e后面要有数字
2 为+-:
第二次出现必须在E和e之后
第一次出现且不在字符开头,必须紧接在e之后
3 为. 只能出现1次,不能在E之后
4 最后判断字符是否合法:'0'~'9'
迭代完毕
return true

//和为S的连续正数序列
int表示成双指针2,1
cur=p1,p2平均值 * p1到p2的连续数列的个数
当总和小于sum，大指针继续+
否则小指针+

//链表中倒数第k个结点
临界判断:k<1或者表null return null
第一个指针B先走k步 B->next,第二个指针A留在原地
只要B能顺利走k步,同时走A->next,B->next,知道B为null,返回A

//最小的K个数
临界情况,长度为0,k小于1:返回空vector<int>()
1 用前k个数造堆 make_heap()造最大堆
2 迭代对k+1(标号k)到vector长度
每次和堆最大值(vector[0])比较,小于当前最大值则:
pop_heap() pop_back(),然后把input[i]加入堆和vector

//二叉搜索树的第k个结点 给定一颗二叉搜索树，请找出其中的第k大的结点
中序遍历:
递归版本:
调用Inorder(pRoot,vec)
return vec[k-1]
Inorder()递归:
递归调用pRoot->left,vec
pRoot压入vec
递归调用pRoot->right,vec

非递归:
while含左子树|| stack非空 {
	node为null:
	node压入stack,node取node.left
	非null:
	node=stack出栈
	计数+1,当计数为k,return node
	node取右子树
}

//二叉搜索树的后序遍历序列
bool judge(vector<int>& a, int l, int r)
最贴近且大于参3 r的a[i],(a[i-1]>a[r] --i),索引i指向为为"根"->与右子树分界线,此时无左子树,i指向为左子树->"根"及右子树
a[j]迭代逐渐减小至l 必须大于a[r]
递归调用(a,l,i-1),(a,i,r-1)

//序列化二叉树
序列化:先序遍历,遇到数值+",",空+"#"
反序列化:"#"则返回同时移动++str,
不是'\0'以及',':将字符转数字
造root结点,递归调用root->left,root->right

//二叉树中和为某一值的路径
全局vector vector<vector> + 递归的简洁方案
FindPath root非空判断,调用DFSfind()
递归DFSfind(node,left):
将left压入vec
若left==node->val相等返回 否则递归调用 node左右子树,取值为left-node-val
vec要pop_back//临时stack当前val已算完

//调整数组顺序使奇数位于偶数前面
冒泡n*n
每次从后面将后奇前偶冒泡到前面i: 0->size()-1 size()-1->i
方法二:空间时间N
统计奇数个数
双指针,一个从0,一个从奇数个数,填入辅助vec
辅助vec填入array

//数据流中的中位数
准备最大堆最小堆
优先压入最大堆,比大顶堆最值大压入小顶堆


//复杂链表的复制
在每个node->next=new Node
node->random->next作为新node的next
拆分:currentNode隔着一个tempNode修改指针,每次currentNode更新为currentNode->next
return pConeHead

//丑数
index<7 输出index
res=min(2t2min(3t3,5t5))
下标t2 t3 t5,每次循环加1

//滑动窗口的最大值
双端队列,vec
迭代数组长度:
队列非空,且小于当前,循环弹出队尾
队列非空,且迭代序号i - s.front>size-1,弹队列头
i压入队列
压入vec.pushback[num[s.front()]]



//删除链表中重复的结点
pHead || pHead->next == null return pHead;
1 新建 newHead防止头结点被删
2 pre=newHead p=pHead next=null
3 while(p和p->next!=null):
	next=p->next;
	if(next非空且值等于p->val){while(next!=null && 值相等)
								{next=next->next}pre->next=next;p=next}
	else{pre=p;p=next	}
4 return newHead->next	
+++++++自创解法
(N-size)/size:
先走size步,遍历:
每次迭代,循环计算出size个数之间的最大值

//第一个只出现一次的字符
第一次遍历->使用std::map存储每个str[i]作为键
第二次遍历->找出键值为1的元素返回
找不到return -1

//矩阵中的路径
递归回溯前:str空不,行列ok不,matrix空不,先造个bool矩阵判读是否走过不
递归回溯(矩阵,总行,总列,所寻字符串,bool矩阵,当下x,当下y):
1 '\0'则true,行列数超范围则返会false
2 走过,bool矩阵[curx*row+cury]则false, 未走过&&matrix[curx*cols+cury]不等则返false
3 记为走过
4 bool sing=递归调用上||下||左||右位置
5 标记为未走过,return sign

//顺时针打印矩阵
计算圈数i
左至右->i为行,i~col-1-i为列
上至下->i+1~row-i为行,col-1-i为列
右至左->row-1-i为行,col-2-i为列,还需判断宽度是否为1
下至上->row-2-i~i-1为行,i为列,还需判断高度是否为1

//机器人的运动范围,假设行列不超过2位数
设置访问标记数组false
递归回溯:
1 检查-> i,j范围,是否已访问,sum(i),sum(j)合法->sum(i){sum+=i%10+i/10}
检查ok则设为已访问,递归return 1+上下左右回溯

//翻转单词顺序列
res存储字符串后面整理好的部分,用于放在空格和tmp之后
tmp存储当前单词和非空格符号,遇到空格会置空为"";
迭代:每次判断是否为空:否追加tmp,是res为" "+tmp+res,tmp=""
迭代结束,tmp非空,res追加tmp,return res

//字符串的排列
非空判断,然后使用递归()
1 若pBegin为'\0' return
2 迭代 PCh指向pBegin,迭代至'\0'
	pBegin和迭代所指的字符(包含自己)交换
	递归调用(pCH,pBegin+1)
	pBegin恢复之前交换的状态

//孩子们的游戏(圆圈中最后剩下的数)
约瑟夫问题经典解法:用std::list模拟
1 填充数据到list
2 while(list.size()>1){
	iterate自加m-1次,到end()重定位begin,得current
	next=++current
	list删除current,让next=current
}
方法二:使用数学上的逆映射

//数组中的逆序对
归并排序的变形
length=(start+end)/2
分治:递归start,start+length  Or 递归 start+length+1,end
合并是,索引靠前数组A,索引靠后数组B:两指针pA,pB初始指向A,B数组尾巴
当pA值>pB值,逆序对增加B数组剩余元素个,pA前移;否则pB前移
剩余的A或B合并完
return count+左递归+右递归

//扑克牌顺子
第一次遍历算出算出大小王的总数
当big索引小于总数时迭代:出现对子会return false;算出空缺位置的总数number[big]-number[small]-1
仅当空缺数<大小王总数为真

//'\0'的ASCII码为0
//res*10 可以改为res<<1 ,数字ASCII转换为数值可以改为 str[i] & 0xf
//使用一个临时的bool变量可以判断这种情况是否是第二次出现
//make_heap()可以对vector进行排序
//第K个xxx问题,除了判断容器非空,还要判读K<1的情况以及k>容器尺寸情况
//字符转数字
while(**str != '\0' && **str != ','){
            num = num*10 + ((**str) - '0');
            ++(*str);
        }


//优先队列最大堆待学习
priority_queue<int, vector<int>, less<int> > 默认最大堆
//qsort return *(int *)a - *(int *)b;  //升序排序
