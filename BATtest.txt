//问题：以下代码的运行情况：ArgumentOrder(printf("a"),printf("b"),printf("c"));
int ArgumentOrder(int a, int b, int c)
{
return 0;
}
//错选：空
//答案：cba
//原因：不懂函数传参机制
在x86架构（Linux或Unix系统）上，函数的参数是通过栈传递的。因此参数从右往左入栈顺序


//问题：具有3个节点的二叉树有几种形态？
//错选：4
//答案：5
//原因：想当然，没动笔画
//解析：
//相关知识点：
性质4：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1
证明：因为二叉树中所有结点的度数均不大于2，所以结点总数(记为n)="0度结点数(n0)" + "1度结点数(n1)" + "2度结点数(n2)"。由此，得到等式一。
(等式一) n=n0+n1+n2
另一方面，0度结点没有孩子，1度结点有一个孩子，2度结点有两个孩子，故二叉树中孩子结点总数是：n1+2n2。此外，只有根不是任何结点的孩子。故二叉树中的结点总数又可表示为等式二。
(等式二) n=n1+2n2+1
由(等式一)和(等式二)计算得到：n0=n2+1。原命题得证！



//问题：在Linux上，对于多进程，子进程继承了父进程的下列哪些？
//错选：共享内存 信号掩码 已打开的文件描述符
//答案：进程地址空间 共享内存 信号掩码 已打开的文件描述符
//原因：
//解析：
1）子进程继承父进程
用户号UIDs和用户组号GIDs
环境Environment
堆栈
共享内存
打开文件的描述符
执行时关闭（Close-on-exec）标志
信号（Signal）控制设定
进程组号
当前工作目录
根目录
文件方式创建屏蔽字
资源限制
控制终端
2）子进程独有
进程号PID
不同的父进程号
自己的文件描述符和目录流的拷贝
子进程不继承父进程的进程正文（text），数据和其他锁定内存（memory locks）
不继承异步输入和输出
//相关知识点：




//问题：文件系统管理的最小磁盘空间单位是
//错选：页面
//答案：簇
//原因：不会
//解析：
微软操作系统（DOS、WINDOWS等）中磁盘文件存储管理的最小单位叫做“簇”
扇区：硬盘不是一次读写一个字节而是一次读写一个扇区（512个字节）
簇：系统读读写文件的基本单位，一般为2的n次方个扇区(由文件系统决定)
块可以包含若干页，页可以包含若干簇，簇可以包含若干扇区
//相关知识点：







不定项选择题
//问题：下列哪些可以用于Linux进程间通讯?
//错选：少选了文件锁
//答案：UNIX套接字 信号量 无名管道 文件锁 共享内存
//原因：概念不全
//解析：文件锁有：读锁与写锁
//相关知识点：



//问题：以下关于死锁，描述正确的有（）
//错选：漏选 有序分配锁资源可以预防死锁
//答案：有序分配锁资源可以预防死锁 剥夺死锁进程的所有资源可以解除死锁
//原因：有序分配误认为是银行家算法那类死锁避免的举措
//解析：有序分配实际是破坏循环等待
//相关知识点：
1）死锁的预防
死锁的预防是保证系统不进入死锁状态的一种策略。它的基本思想是要求进程申请资源时遵循某种协议，从而打破产生死锁的四个必要条件中的一个或几个，保证系统不会进入死锁状态。
打破互斥条件；
打破不可抢占条件；
打破占有且申请条件；
2）死锁避免
安全序列；
银行家算法；


//问题：关系模式R中的属性全是主属性，则R的最高范式必定是（）
//错选：BCNF
//答案：3NF
//原因：范式概念模糊
//解析：
R(X,Y,Z),  F={Y->Z, XZ->Y}.
XY作为候选码 3NF ； XZ作为候选码BCNF
//相关知识点：
1NF
强调的是列的原子性，即列不能够再分成其他几列
2NF
没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分
3NF
不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况
BCNF
必须不存在对主属性的部分函数依赖
啰嗦一句：2NF：非主键列是否完全依赖于主键，还是依赖于主键的一部分；3NF：非主键列是直接依赖于主键，还是直接依赖于非主键列。


//问题：现有数据库表t_order,主键为Forder_id,并在表的Fuin、Fstate、Fcreate、ime建立复合索引，下列选项中能使索引的是（    ）
//错选：不会
//答案：select Fmerchant_id,Forder_id FROM t_order WHERE Fuin=’42176034’ AND Fstate=1;
//原因：
//解析：
如果一个 Like 语句的查询条件不以通配符起始则使用索引
%车 或 %车%   不使用索引。
车%              使用索引。
//相关知识点：
索引的使用限制场合：
1）使用不等于操作符(<>, !=)
2）使用 is null 或 is not null
3）没有使用基于函数的索引，那么where子句中对存在索引的列使用函数时，会使优化器忽略掉这些索引
select * from staff where trunc(birthdate) = '01-MAY-82'; 不使用索引
select * from staff where birthdate < (to_date('01-MAY-82') + 0.9999); 使用索引
4）比较不匹配的数据类型
select * from dept where dept_id = 900198;
不使用索引，oracle会自动把where子句转换成to_number(dept_id)=900198
select * from dept where dept_id = '900198';





//问题：下面关于数据库唯一索引正确的是（ ）？
//错选：多选了不能用来定义外键
//答案：
//原因：
//解析：
//相关知识点：
1.主键约束（PRIMARY KEY）
1) 主键用于唯一地标识表中的每一条记录，可以定义一列或多列为主键。 
2) 是不可能（或很难）更新． 
3) 主键列上没有任何两行具有相同值（即重复值），不允许空（NULL）．
4) 主健可作外健，唯一索引不可；
2.唯一性约束（UNIQUE）
1) 唯一性约束用来限制不受主键约束的列上的数据的唯一性，用于作为访问某行的可选手段，一个表上可以放置多个唯一性约束．
2) 只要唯一就可以更新． 
3) 即表中任意两行在  指定列上都不允许有相同的值，允许空（NULL）．
4) 一个表上可以放置多个唯一性约束


3.唯一性约束和主键约束的区别：
1）唯一性约束允许在该列上存在NULL值，而主键约束的限制更为严格，不但不允许有重复，而且也不允许有空值。
2）在创建唯一性约束和主键约束时可以创建聚集索引和非聚集索引，但在 默认情况下主键约束产生聚集索引，而唯一性约束产生非聚集索引约束和索引， 前者是用来检查数据的正确性，后者用来实现数据查询的优化，目的不同。
4.唯一性约束与唯一索引有所不同（唯一约束是通过创建唯一索引来实现的）：
1）创建唯一约束会在Oracle中创建一个Constraint，同时也会创建一个该约束对应的唯一索引。
2）创建唯一索引只会创建一个唯一索引，不会创建Constraint。
删除唯一约束时可以只删除约束而不删除对应的索引，所以对应的列还是必须唯一的，
而删除了唯一索引的话就可以插入不唯一的值


//问题：
#include<stdio.h>
  
class A
{
public:
A(){ printf(“A”);}
~A(){ printf(“~A”);
};
class B:public A
{
public;
B(){ printf(“B”);}
~B(){ printf(“~B”);}
};
  
int main()
{
A*c = new B[2];
delete[] c;
return 0;
}
//错选：ABAB`~B~A~B~A
//答案：ABAB`~A~A
//原因：delete数组时不能像delete单个对象一样
//解析：
编译器需要建立起遍历数组来调用析构函数的代码；这样他不得不先确定数组的大小；编译器把指针p指向的静态类型的大小和析构函数指针一并传给delete运算符
而这二者都与实际不符，所以最终没有调用到派生类的destructor
//相关知识点：



//问题：寝室有6个同学打dota，分为对立的两方，一方是天灾军团，一方是近卫军团。现请你设置赛程以及每场的对阵（每方最少1人、最多5人），请问至少得进行多少场比赛，才能使得赛程结束后每位同学都和其他同学做过对手（）
//错选：空
//答案：3
//原因：用二进制标识状态和个体
//解析：至少用3位二进制就能标识6位同学，如000，001，010，011，100，101，第一第二第三场分别转换为二进制的各个数位
而每一种表示都与其他7种的表示至少在一个位置上的数字是不一样的===二进制数不同====三场中至少有一场在不同阵营
//相关知识点：

//问题：关于c++的inline关键字,以下说法正确的是()
//错选：优先使用Class声明内定义的inline函数
//答案：定义在Class声明内的成员函数默认是inline函数
//原因：
//解析：
//相关知识点：
如果只声明含有inline关键字，就没有内联的效果
内联函数应该在头文件中定义	
内联函数定义也可以放在源文件中，但此时只有定义的那个源文件可以用它
内联函数最好只有一个定义

//问题：下面关于系统调用的描述中,错误的是()
//错选：系统调用给用户屏蔽了设备访问的细节
//答案：系统调用中被调用的过程运行在"用户态"中
//原因：不清楚系统存在两类空间，在空间上分割了用户态和系统态
//解析：用户空间与系统空间所在的内存区间不一样，同样，对于这两种区间，CPU的运行状态也不一样。 在用户空间中，CPU处于"用户态"；在系统空间中，CPU处于"系统态"。
系统调用通过中断完成，这一过程中系统由用户态变为内核态。 在内核态下，系统可以无限制的访问内核资源
//相关知识点：


//问题：n个数值选出最大m个数（3<m<n）的最小算法复杂度是
//错选：O(nlogn)
//答案：O(n)
//原因：不能活用快排
//解析：
1.最简单的方法：将n个数排序，排序后的前k个数就是最大的k个数，这种算法的复杂度是O（nlogn）
2.O（n）的方法：利用快排的patition思想，基于数组的第k个数来调整，将比第k个数小的都位于数组的左边，比第k个数大的都调整到数组的右边，这样调整后，位于数组右边的k个数最大的k个数(这k个数不一定是排好序的）
3.O(nlogk）的方法：先创建一个大小为k的最小堆，接下来我们每次从输入的n个整数中读入一个数，如果这个数比最小堆的堆顶元素还要大，那么替换这个最小堆的堆顶并调整。
//相关知识点：





//问题：阿里巴巴国际站的股票代码是1688，这个数字具有这样的特性，首先是个首位为1的4位数，其次恰巧有且仅有1个数字出现了两次。类似的数字还有：1861,1668等。这样的数字一共有()个。
//错选：270
//答案：432
//原因：考虑不周全；思路要开阔，推导要细致
//解析：
分两种情况讨论：
（1）若这个四位数的重复数字为1，那么首先从三个空位中选出一个给1，第二步从剩下9个可选数字中选出2个有序的排列到剩下的两个空位中去，那么有C(1，3)*A(2，9)=3*(9!/(9-2)!)=3*9*8=216种可能；
（2）若这个四位数的重复数字不为1，那么首先从9个可选数字中选出一个作为重复数字(C(1,9))，并放到三个空位中的两个（这两个数字相同，故只涉及组合）(C(2, 3))，然后从剩下8个数字中选出一个（它的位置在重复数字确定后就自然固定了，不可选）即可，故有C(1,9)*C(2, 3)*C(1, 8)=216种可能。
总共：216+216=432
//相关知识点：


//问题：以下哪种方式，在读取磁盘上多个顺序数据块时的效率最高？
//错选：DMA方式
//答案：通道方式
//原因：读取顺序数据块的方式没研究
//解析：程序直接访问：字节、字；中断：字；DMA：块；通道：多个块
//相关知识点：
（1）程序直接访问方式跟循环检测IO方式，应该是一个意思吧，是最古老的方式。CPU和IO串行，每读一个字节（或字），CPU都需要不断检测状态寄存器的busy标志，当busy=1时，表示IO还没完成；当busy=0时，表示IO完成。此时读取一个字的过程才结束，接着读取下一个字。
（2）中断控制方式：循环检测先进些，IO设备和CPU可以并行工作，只有在开始IO和结束IO时，才需要CPU。但每次只能读取一个字。
（3）DMA方式：Direct Memory Access，直接存储器访问，比中断先进的地方是每次可以读取一个块，而不是一个字。
（4）通道方式：比DMA先进的地方是，每次可以处理多个块，而不只是一个块。


//问题：已知IBM的PowerPC是big-endian字节序列而Intel的X86是little-endian字节序，如果在地址A存储的整形值时0x04030201(数据4321？？)，那么地址为a+3的字节内存储的值在PowerPC和Intel X86结构下的值分别是？
//错选：4  1
//答案：1  4
//原因：存储顺序记反了
//解析：数据低位开始存===大端从高地址到低地址；小端从低地址到高地址===大端读取时地址递减,小端读取时地址递增
//相关知识点：
大端从高地址开始存储数据的低字节(题目只给了地址，没给数据）；
大端小端都是从数据低位开始读取，即大端从高地址到低地址；小端从低地址到高地址


//问题：
#pragma pack(2)
class BU
{
    int number;
    union UBffer
    {
        char buffer[13];
        int number;
    }ubuf;
    void foo(){}
    typedef char*(*f)(void*);
    enum{hdd,ssd,blueray}disk;
}bu;
//错选：空
//答案：22
//原因：联合体的空间分配机制
//解析：
int number;
union UBffer
{
        char buffer[13]; // 13
        int number; // 4
}ubuf; buffer 是13个字节，number 是4个字节，取最大的 为13，注意还要字节对齐，对齐字节数为2，所以Union大小为14，既满足buffer的对齐 也满足number的对齐。
void foo(){} 不占
typedef char*(*f)(void*); 不占
enum{hdd,ssd,blueray}disk; 4个字节
综上，总大小为4+14+0+0+4=22
//相关知识点：
1）union:当多个数据需要共享内存或者多个数据每次只取其一时，可以利用联合体(union)；
它有以下特点：
    （1）它是一个结构；
    （2）它的所有成员相对于基地址的偏移量都为0；
    （3）此结构空间要大到足够容纳最"宽"的成员；
    （4）其对齐方式要适合其中所有的成员
综上:
而分配给union的实际大小不仅要满足是对齐大小的整数倍，同时要满足实际大小不能小于最大成员的大小。
2）#pragma pack(n)来设定变量以n字节对齐方式
如果n大于等于该变量所占用的字节数，那么偏移量必须满足默认的对齐方式，取n
如果n小于该变量的类型所占用的字节数，那么偏移量为n的倍数，不用满足默认的对齐方式





//问题：程序的运行结果是：
int* pint = 0; 
pint += 6; 
cout << pint << endl;
//错选：任意数
//答案：24
//原因：看错题意，pint是指针，不是整型变量
//解析：
对指针做加法，根据指针所指的数据类型确定偏移量，int时+1偏移4字节
//相关知识点：




//问题：刚毕业的小王上班有两路公交车都可以从家到公司.如果只等A车,平均需要5分钟才等到;如果只等B车,平均需要7分钟才能等到.假定两辆车运行时间独立,那么小王平均需要等多长时间才能等到A车或B车?
//错选：3分钟
//答案：2分55秒
//原因：周期转化成频率,再用总速度/频率之和得到两种情况的周期;不确定频率可以直接相加
//解析：
思路一：
设置变量t：在t时间内，A车t/5趟,B车t/7趟,t/(t/5+t/7)=35/12
思路二：
35分钟内一共来了12辆车
平均每 35/12 min 来一辆。
35/12min = 2min55s
//相关知识点：





//问题：
//错选：
//答案：
//原因：
//解析：
//相关知识点：



//问题：
//错选：
//答案：
//原因：
//解析：
//相关知识点：




//问题：
//错选：
//答案：
//原因：
//解析：
//相关知识点：







//问题：
//错选：
//答案：
//原因：
//解析：
//相关知识点：











//问题：
//错选：
//答案：
//原因：
//解析：
//相关知识点：









//问题：
//错选：
//答案：
//原因：
//解析：
//相关知识点：











//问题：
//错选：
//答案：
//原因：
//解析：
//相关知识点：









//问题：
//错选：
//答案：
//原因：
//解析：
//相关知识点：

//===========================================计算机网络====================================

//问题：ARP协议实现的功能是()

//错选：物理地址到IP地址的解析
//答案：IP地址到物理地址的解析
//原因：
//解析：
1)地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。
2)地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；
//相关知识点：


//问题：在公司局域网上ping www.qq.com没有涉及到的网络协议是：（    ）
//错选：ARP
//答案：TCP
//原因：遗忘ICMP概念
//解析：
ping 使用的协议为icmp，通过域名解析，需要用到DNS，局域网中使用arp进行主机间的通信。TCP层是位于IP层之上,应用层之下的中间层
//相关知识点：
通常用于返回的错误信息或是分析路由
错误消息包括源数据并返回给发送者，例子：TTL过期


//问题：IP地址为140.123.0.0的地址是B类地址，若要切割为10个子网，而且都要连接上Internet，请问子网掩码应设为（）
//错选：概念遗忘
//答案：255.255.240.0
//原因：不会
//解析：
默认B类地址的子网掩码是/16，也就是255.255.0.0
切割成10个子网的话，就得向主机位借2的四次方=16＞10，即向主机位借4位。
所以子网掩码要设置成/20，也就是255.255.240.0
//相关知识点：
地址分类：ABCD 默认子关掩码255.0.0.0;255.255.0.0;255.255.255.0;未定义
IP地址：类似于你这台电脑的标志，但在网络上是靠IP地址识别的。如果利用TCP/IP协议组网，那么一个网段内的所有电脑都必须有一个IP地址，并且不能重复。
子网掩码和IP地址是配合一起的，将IP地址分成两段，网络段（1）和主机段（0）。



模糊：
TCP/IP模型中，ARP协议属于网络层；在OSI参考模型中，ARP属于数据链路层23
应用层：FTP；HTTP
网络层：ICMP
传输层：UDP

VPN隧道协议4种：
a数据链路层 点到点隧道协议PPTP
b数据链路层 第二层隧道协议L2TP
c网络层 隧道协议IPSec
d会话层 SOCKS v5协议

